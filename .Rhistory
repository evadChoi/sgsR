algorithm = "lcube",
plot = TRUE)
#--- need to add a variable named strata to enable stratified sampling ---#
mraster <- c(wall_poly,kmeans)
#--- stratified sampling with access and buffers provided ---#
bal_wo <- sample_balanced(mraster = mraster,
n = 200,
algorithm = "lcubestratified",
plot = TRUE)
#--- stratified sampling with access and buffers provided ---#
bal_w_a <- sample_balanced(mraster = mraster,
n = 200,
algorithm = "lcubestratified",
access = roads,
buff_inner = 50,
buff_outer = 200,
plot = TRUE)
#--- extract strata from raster for already existing sample network ---#
#--- we use random samples defined above ---#
existing <- extract_existing(sraster = kmeans,
existing = srs_wo)
existing
#--- if 'data.frame = TRUE -- output will be a dataframe instead of an sf object ---#
#--- sampling **with** access defined **and** existing samples defined ---#
#--- we want 200 samples with 200m min distance between each ---#
#--- we specify we have an existing plot network to include in our sampling ---#
#--- we also provide an `access` polygon, which is linear road features ---#
#--- we specify we want an internal buffer ('buff_inner') of 50 ---#
#--- we also specify we want an external buffer ('buff_outer') of 200 ---#
strat_w_e <- sample_strat(sraster = sraster,
n = 200,
mindist = 200,
existing = existing,
access = roads,
buff_inner = 50,
buff_outer = 200,
plot = TRUE)
srs_wo
extract_existing(sraster = kmeans,
existing = srs_wo)
existing <- extract_existing(sraster = kmeans,
existing = srs_wo)
existing
sample_strat(sraster = sraster,
n = 200,
mindist = 200,
existing = existing,
access = roads,
buff_inner = 50,
buff_outer = 200,
plot = TRUE)
existing
inherits(sf::st_geometry(existing)
)
inherits(sf::st_geometry(existing),"sfc_POINT")
load_all()
#--- sampling **with** access defined **and** existing samples defined ---#
#--- we want 200 samples with 200m min distance between each ---#
#--- we specify we have an existing plot network to include in our sampling ---#
#--- we also provide an `access` polygon, which is linear road features ---#
#--- we specify we want an internal buffer ('buff_inner') of 50 ---#
#--- we also specify we want an external buffer ('buff_outer') of 200 ---#
strat_w_e <- sample_strat(sraster = sraster,
n = 200,
mindist = 200,
existing = existing,
access = roads,
buff_inner = 50,
buff_outer = 200,
plot = TRUE)
load_all()
#--- sampling **with** access defined **and** existing samples defined ---#
#--- we want 200 samples with 200m min distance between each ---#
#--- we specify we have an existing plot network to include in our sampling ---#
#--- we also provide an `access` polygon, which is linear road features ---#
#--- we specify we want an internal buffer ('buff_inner') of 50 ---#
#--- we also specify we want an external buffer ('buff_outer') of 200 ---#
strat_w_e <- sample_strat(sraster = sraster,
n = 200,
mindist = 200,
existing = existing,
access = roads,
buff_inner = 50,
buff_outer = 200,
plot = TRUE)
existing
st_geometry(existing)
sf::st_geometry(existing)
sf::st_geometry(roads)
inherits(sf::st_geometry(existing),"sfc_POINT")
load_all()
#--- sampling **with** access defined **and** existing samples defined ---#
#--- we want 200 samples with 200m min distance between each ---#
#--- we specify we have an existing plot network to include in our sampling ---#
#--- we also provide an `access` polygon, which is linear road features ---#
#--- we specify we want an internal buffer ('buff_inner') of 50 ---#
#--- we also specify we want an external buffer ('buff_outer') of 200 ---#
strat_w_e <- sample_strat(sraster = sraster,
n = 200,
mindist = 200,
existing = existing,
access = roads,
buff_inner = 50,
buff_outer = 200,
plot = TRUE)
#--- red plots are existing and black are new ---#
#--- how many samples did we get total? ---#
strat_w_e
#--- sampling **with** access defined **and** existing samples defined ---#
#--- we want 200 samples with 200m min distance between each ---#
#--- we specify we have an existing plot network to include in our sampling ---#
#--- we also provide an `access` polygon, which is linear road features ---#
#--- we specify we want an internal buffer ('buff_inner') of 50 ---#
#--- we also specify we want an external buffer ('buff_outer') of 200 ---#
strat_w_e_i <- sample_strat(sraster = kmeans,
n = 200,
mindist = 200,
existing = existing,
include = TRUE, #--- including our existing plots to reach 200 samples ---#
access = roads,
buff_inner = 50,
buff_outer = 200,
plot = TRUE)
#--- how many samples did we get total? ---#
strat_w_e_i
#--- extract metrics from multi-band ALS raster for potential modeling ---#
metrics <- extract_metrics(mraster = wall_poly,
samples = strat_w_e_i)
metrics
#--- if 'data.frame = TRUE -- output will be a dataframe instead of an sf object ---#
check()
dplyr::leadload_all()
load_all()
load_all()
load_all()
load_all()
load_all()
check()
load_all()
check()
load_all()
check()
load_all()
check()
load_all()
chekc()
check()
#--- perform stratification using principal components on P1 and P2 ---#
pcomp2 <- strat_pcomp(mraster = wall_poly,
nstrata = 4,
nstrata2 = 3)
load_all()
#--- perform stratification using principal components on P1 only ---#
pcomp1 <- strat_pcomp(mraster = wall_poly,
nstrata = 4)
plot(pcomp1)
#--- perform stratification using principal components on P1 and P2 ---#
pcomp2 <- strat_pcomp(mraster = wall_poly,
nstrata = 4,
nstrata2 = 3)
#--- number of output strata will always be equal to ---#
#--- 'nstrata' * 'nstrata2' (if 'nstrata2' is provided) ---#
plot(pcomp2)
#--- set 'details' = TRUE to get algorithm details and outputs ---#
load_all()
#--- perform stratification using principal components on P1 and P2 ---#
pcomp2 <- strat_pcomp(mraster = wall_poly,
nstrata = 4,
nstrata2 = 3)
load_all()
#--- perform stratification using principal components on P1 and P2 ---#
pcomp2 <- strat_pcomp(mraster = wall_poly,
nstrata = 4,
nstrata2 = 3)
load_all()
#--- perform stratification using principal components on P1 and P2 ---#
pcomp2 <- strat_pcomp(mraster = wall_poly,
nstrata = 4,
nstrata2 = 3)
#--- number of output strata will always be equal to ---#
#--- 'nstrata' * 'nstrata2' (if 'nstrata2' is provided) ---#
plot(pcomp2)
#--- set 'details' = TRUE to get algorithm details and outputs ---#
check()
use_package("magrittr",min_version = TRUE)
check()
use_package("methods",version=TRUE)
library(devtools)
load_all()
use_package("methods",version=TRUE)
use_package("methods")
load_all()
check()
use_package("rlang",min_version = TRUE)
load_all()
check()
#--- define desired stratification raster ---#
sraster <- metrics2
#--- perform stratification using an individual metric ---#
metrics2 <- strat_quantiles(mraster = wall_poly,
metric = "zmean",
nstrata = 10)
#--- perform stratification using an individual metric ---#
#--- if no 'metric' name defined and raster is 1 layer - automatically uses only available layer ---#
metrics1 <- strat_quantiles(mraster = wall_poly[[1]],
nstrata = 5)
#--- perform stratification using principal components on P1 and P2 ---#
pcomp2 <- strat_pcomp(mraster = wall_poly,
nstrata = 4,
nstrata2 = 3)
mraster <- terra::mask(raster,
poly_subset)
load_all()
library(sgsR)
library(terra)
library(sf)
library(RColorBrewer)
library(dplyr)
library(tidyr)
library(ggplot2)
library(spatstat)
#--- import ALS metrics raster ---#
raster <- system.file("extdata","rmf_metrics.tif", package = "sgsR")
raster <- terra::rast(raster)
names(raster) <- c("zmax","zmean","zsd","pzabove2","zq20","zq50","zq70","zq90","zq95","l_1","l_2","t_3","t_4")
#--- import forest inventory polygon and mask unwanted areas ---#
poly <- system.file("extdata","inventory_polygons.shp", package = "sgsR")
poly <- sf::st_read(poly)
#--- import access layer to be used during sampling if desired ---#
roads <- system.file("extdata","roads.shp", package = "sgsR")
roads <- sf::st_read(roads)
#--- manipulate inventory polygon to mask out unwanted areas ---#
poly_subset <- poly[poly$POLYTYPE == "FOR" & poly$OWNER == 1, ]
poly_subset <- sf::st_union(poly_subset)
poly_subset <- terra::vect(poly_subset)
#--- mask input ALS raster using polygon layer ---#
wall_poly <- terra::mask(raster,
poly_subset)
terra::plot(wall_poly[[1:2]])
#--- perform stratification using k-means ---#
kmeans <- strat_kmeans(mraster = wall_poly[[1]], nstrata = 4)
plot(kmeans)
#--- set 'details' = TRUE to get algorithm details and outputs ---#
#--- perform stratification using OSB ---#
#--- note that this one can take a while ---#
osb <- strat_osb(mraster = wall_poly,
metric = "pzabove2",
nstrata = 4,
n = 20,
details = TRUE)
load_all()
#--- perform stratification using OSB ---#
#--- note that this one can take a while ---#
osb <- strat_osb(mraster = wall_poly,
metric = "pzabove2",
nstrata = 4,
n = 20,
details = TRUE)
load_all()
#--- perform stratification using OSB ---#
#--- note that this one can take a while ---#
osb <- strat_osb(mraster = wall_poly,
metric = "pzabove2",
nstrata = 4,
n = 20,
details = TRUE)
load_all()
#--- perform stratification using OSB ---#
#--- note that this one can take a while ---#
osb <- strat_osb(mraster = wall_poly,
metric = "pzabove2",
nstrata = 4,
n = 20,
details = TRUE)
#--- perform stratification using user-defined breaks ---#
#--- define breaks for metric ---#
breaks <- c(seq(5,20,5))
breaks
#--- stratify on 1 metric only ---#
bk1 <- strat_breaks(mraster = wall_poly,
metric = "zmean",
breaks = breaks,
details = TRUE,
plot = TRUE)
#--- stratify on 2 metrics ---#
breaks2 <- c(seq(3,30,10))
breaks2
bk2 <- strat_breaks(mraster = wall_poly,
metric = "zmean",
metric2 = "zq95",
breaks = breaks,
breaks2 = breaks2,
details = TRUE,
plot = TRUE)
#--- perform stratification using principal components on P1 only ---#
pcomp1 <- strat_pcomp(mraster = wall_poly,
nstrata = 4)
plot(pcomp1)
#--- perform stratification using principal components on P1 and P2 ---#
pcomp2 <- strat_pcomp(mraster = wall_poly,
nstrata = 4,
nstrata2 = 3)
#--- number of output strata will always be equal to ---#
#--- 'nstrata' * 'nstrata2' (if 'nstrata2' is provided) ---#
plot(pcomp2)
#--- set 'details' = TRUE to get algorithm details and outputs ---#
#--- perform stratification using an individual metric ---#
#--- if no 'metric' name defined and raster is 1 layer - automatically uses only available layer ---#
metrics1 <- strat_quantiles(mraster = wall_poly[[1]],
nstrata = 5)
plot(metrics1)
#--- perform stratification using an individual metric ---#
#--- if no 'metric' name defined and raster is 1 layer - automatically uses only available layer ---#
metrics1 <- strat_quantiles(mraster = wall_poly[[3]],
nstrata = 5)
plot(metrics1)
load_all()
#--- perform stratification using principal components on P1 and P2 ---#
pcomp2 <- strat_pcomp(mraster = wall_poly,
nstrata = 4,
nstrata2 = 3)
#--- number of output strata will always be equal to ---#
#--- 'nstrata' * 'nstrata2' (if 'nstrata2' is provided) ---#
plot(pcomp2)
#--- set 'details' = TRUE to get algorithm details and outputs ---#
#--- perform stratification using an individual metric ---#
#--- if no 'metric' name defined and raster is 1 layer - automatically uses only available layer ---#
metrics1 <- strat_quantiles(mraster = wall_poly[[3]],
nstrata = 5)
plot(metrics1)
load_all()
#--- perform stratification using an individual metric ---#
#--- if no 'metric' name defined and raster is 1 layer - automatically uses only available layer ---#
metrics1 <- strat_quantiles(mraster = wall_poly[[3]],
nstrata = 5)
plot(metrics1)
#--- perform stratification using an individual metric ---#
metrics2 <- strat_quantiles(mraster = wall_poly,
metric = "zmean",
nstrata = 10)
plot(metrics2)
#--- perform stratification using 2 metrics metrics ---#
metrics3 <- strat_quantiles(mraster = wall_poly,
metric = "zmean",
metric2 = "zq95",
nstrata = 10,
nstrata2 = 5)
plot(metrics3)
#--- number of output strata will always be equal to ---#
#--- 'nstrata' * 'nstrata2' (if 'nstrata2' is provided) ---#
load_all()
#--- perform stratification using an individual metric ---#
metrics2 <- strat_quantiles(mraster = wall_poly,
metric = "zmean",
nstrata = 10)
plot(metrics2)
#--- perform stratification using 2 metrics metrics ---#
metrics3 <- strat_quantiles(mraster = wall_poly,
metric = "zmean",
metric2 = "zq95",
nstrata = 10,
nstrata2 = 5)
plot(metrics3)
#--- number of output strata will always be equal to ---#
#--- 'nstrata' * 'nstrata2' (if 'nstrata2' is provided) ---#
#--- define desired stratification raster ---#
sraster <- metrics2
#--- SRS **without** access defined---#
#--- 'mindist' between samples defaults to 100 ---#
srs_wo <- sample_srs(sraster = sraster,
n = 50,
plot = TRUE)
load_all()
#--- define desired stratification raster ---#
sraster <- metrics2
#--- SRS **without** access defined---#
#--- 'mindist' between samples defaults to 100 ---#
srs_wo <- sample_srs(sraster = sraster,
n = 50,
plot = TRUE)
#--- increase desired samples and mindist parameter ---#
srs_md <- sample_srs(sraster = sraster,
n = 300,
mindist = 400,
plot = TRUE)
#--- sampling **with** access defined---#
#--- we want 200 samples with 200m min distance between each ---#
#--- we also provide an `access` polygon, which is linear road features ---#
#--- we specify we want an internal buffer ('buff_inner') of 50 ---#
#--- we also speficy we want an external buffer ('buff_outer') of 200 ---#
srs_w <- sample_srs(sraster = sraster,
n = 200,
mindist = 200,
access = roads,
buff_inner = 50,
buff_outer = 200,
plot = TRUE)
#--- stratified sampling **without** access defined---#
#--- 'mindist' between samples defaults to 100 ---#
strat_wo <- sample_strat(sraster = sraster,
n = 200,
plot = TRUE)
load_all()
#--- stratified sampling **without** access defined---#
#--- 'mindist' between samples defaults to 100 ---#
strat_wo <- sample_strat(sraster = sraster,
n = 200,
plot = TRUE)
#--- change mindist parameter ---#
strat_md <- sample_strat(sraster = sraster,
n = 200,
mindist = 200,
plot = TRUE)
load_all()
check()
load_all()
check()
use_package("spatstat.geom", min_version = TRUE)
use_package("plyr", min_version = TRUE)
check(vignettes = FALSE)
load_all()
check(vignettes = FALSE)
load_all()
check(vignettes = FALSE)
check(vignettes = FALSE)
check(vignettes = FALSE)
use_citation()
load_all()
check(vignettes = FALSE)
citation("sgsR")
check()
check(vignettes = FALSE)
citation("sgsR")
check(vignettes = FALSE)
check(vignettes = FALSE)
check(vignettes = FALSE)
check(vignettes = FALSE)
check(vignettes = FALSE)
citation("sgsR")
sub("-.*", "", meta$Date)
sprintf("R package version %s", meta$Version)
format(Sys.Date(), "%Y")
check(vignettes = FALSE)
citation("sgsR")
load_all()
citation("sgsR")
print(<citation>, bibtex=TRUE)
print(citation("sgsR"), bibtex=TRUE)
load_all()
citation("sgsR")
load_all()
citation("sgsR")
load_all()
citation("sgsR")
load_all()
citation("sgsR")
load_all()
citation("sgsR")
load_all()
citation("sgsR")
load_all()
citation("sgsR")
load_all()
citation("sgsR")
author <- as.person("Tristan RH Goodbody")
author
bibentry(bibtype = "Manual",
title = "sgsR: Structurally Guided Sampling Approaches using ALS Data for R",
author = author,
year = year,
note = note,
url = "https://github.com/tgoodbody/sgsR")
year <- sub("-.*", "", meta$Date)
note <- sprintf("R package version %s", meta$Version)
author <- as.person("Tristan RH Goodbody")
bibentry(bibtype = "Manual",
title = "sgsR: Structurally Guided Sampling Approaches using ALS Data for R",
author = author,
year = year,
note = note,
url = "https://github.com/tgoodbody/sgsR")
load_all()
citation("sgsR")
load_all()
citation("sgsR")
load_all()
citation("sgsR")
print(citation("sgsR"),bibtex = TRUE)
load_all()
print(citation("sgsR"),bibtex = TRUE)
load_all()
print(citation("sgsR"),bibtex = TRUE)
load_all()
print(citation("sgsR"),bibtex = TRUE)
load_all()
print(citation("sgsR"),bibtex = TRUE)
load_all()
print(citation("sgsR"),bibtex = TRUE)
load_all()
print(citation("sgsR"),bibtex = TRUE)
load_all()
print(citation("sgsR"),bibtex = TRUE)
load_all()
print(citation("sgsR"),bibtex = TRUE)
load_all()
print(citation("sgsR"),bibtex = TRUE)
load_all()
print(citation("sgsR"),bibtex = TRUE)
check('')
check()
install.packages("qpdf")
check()
