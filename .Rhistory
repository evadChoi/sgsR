#--- Outline quantiles that are underrepresented (< 1) in the sample ---#
notRep <- which(ratio < 1, arr.ind = TRUE)
notRep <- cbind(notRep,which(ratio < 1))
#--- begin sampling from highest discrepancy to lowest ---#
newSamp <- nSamp
position <- 1
samples
repRank <- which(notRep[,3] == ratOrder[1])
repRow <- notRep[repRank,1]
repcol <- notRep[repRank,2]
sampExist <- floor(nrow(samples) * matCovSampDens[repRow,repcol])
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repcol])
sampNeed <- sampOptim - sampExist
if(newSamp < sampNeed) sampNeed <- newSamp
covLower <- mats$matQ[repRow,repCol]
covUpper <- mats$matQ[repRow + 1,repCol]
valsSub <- vals[vals[,(2 + repCol)] >= covLower & vals[,(2 + repCol)] <= covUpper,]
addSamp <- sample(nrow(valsSub), sampNeed)
valsSubSamp <- valsSub[addSamp,]
valsSubSamp$type <- "new"
vals <- vals[-addSamp,]
samples <- rbind(samples,valsSubSamp)
valsSubSamp
valsSub <- vals[vals[,(2 + repCol)] >= covLower & vals[,(2 + repCol)] <= covUpper,]
valsSub
vals
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals
terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE) %>%
rename(x = X,
y = Y)
terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE) %>%
rename(X = x,
Y = y)
#--- determine number of bands in 'mraster' ---#
nb <- terra::nlyr(mraster)
#--- extract covariates data from mraster ---#
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE) %>%
dplyr::rename(X = x,
Y = y)
#--- Remove NA / NaN / Inf values ---#
vals <- vals %>%
dplyr::filter(complete.cases(.))
#--- Generate quantile matrix ---#
mats <- analyze_popLHC(mraster = mraster,PCA = FALSE, nQuant = nQuant)
#--- Change 0's to very small number to avoid division issues ---#
mats$matCov[which(mats$matCov == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovDens <- mats$matCov / nrow(vals)
###--- Prepare existing sample data ---###
#--- extract covariates at existing sample locations ---#
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
#--- Assign code to differentiate between original samples and those added during HELS algorithm ---#
samples$type <- "existing"
#--- Create data hypercube of existing samples to compare with mraster data ---#
matCovSamp <- mat_cov(vals = samples[3:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
#--- Change 0's to very small number to avoid division issues ---#
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovSampDens <- matCovSamp / nrow(samples)
###--- Selection of new samples based on density ---###
#--- Ratio and ordering of data density and covariate density ---#
ratio <- matCovSampDens / matCovDens
#--- order the densities based on lowest representation ---#
ratOrder <- order(ratio)
#--- Outline quantiles that are underrepresented (< 1) in the sample ---#
notRep <- which(ratio < 1, arr.ind = TRUE)
notRep <- cbind(notRep,which(ratio < 1))
#--- begin sampling from highest discrepancy to lowest ---#
newSamp <- nSamp
position <- 1
#--- begin while loop to sample ---#
repRank <- which(notRep[,3] == ratOrder[1])
repRow <- notRep[repRank,1]
repcol <- notRep[repRank,2]
sampExist <- floor(nrow(samples) * matCovSampDens[repRow,repcol])
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repcol])
sampNeed <- sampOptim - sampExist
if(newSamp < sampNeed) sampNeed <- newSamp
covLower <- mats$matQ[repRow,repCol]
covUpper <- mats$matQ[repRow + 1,repCol]
valsSub <- vals[vals[,(2 + repCol)] >= covLower & vals[,(2 + repCol)] <= covUpper,]
addSamp <- sample(nrow(valsSub), sampNeed)
valsSubSamp <- valsSub[addSamp,]
valsSubSamp$type <- "new"
vals <- vals[-addSamp,]
samples <- rbind(samples,valsSubSamp)
samples
samples %>% filter(type == "new")
load_all()
analyze_HELS(mraster = mraster, existing = existing, nQuant = 10, nSamp = 200)
load_all()
analyze_HELS(mraster = mraster, existing = existing, nQuant = 20, nSamp = 100,plot=TRUE)
analyze_HELS(mraster = mraster[[1:3]], existing = existing, nQuant = 20, nSamp = 100,plot=TRUE)
nb <- terra::nlyr(mraster[[1:3]])
nb
vals <- terra::as.data.frame(mraster[[1:3]], xy = TRUE, row.names = FALSE) %>%
dplyr::rename(X = x,
Y = y)
vals
mats <- analyze_popLHC(mraster = mraster[[1:3]],PCA = FALSE, nQuant = nQuant)
mats
samples <- extract_metrics(mraster[[1:3]], existing, data.frame = TRUE)
samples
matCovSamp <- mat_cov(vals = samples[3:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
matCovSamp
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
matCovSampDens <- matCovSamp / nrow(samples)
ratio <- matCovSampDens / matCovDens
ratOrder <- order(ratio)
ratio
matCovDens
matCovSampDens
#--- determine number of bands in 'mraster' ---#
nb <- terra::nlyr(mraster[[1:3]])
#--- determine crs of input sraster ---#
crs <- crs(mraster)
#--- extract covariates data from mraster ---#
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE) %>%
dplyr::rename(X = x,
Y = y)
#--- Remove NA / NaN / Inf values ---#
vals <- vals %>%
dplyr::filter(complete.cases(.))
#--- Generate quantile matrix ---#
mats <- analyze_popLHC(mraster = mraster[[1:3]],PCA = FALSE, nQuant = nQuant)
#--- Change 0's to very small number to avoid division issues ---#
mats$matCov[which(mats$matCov == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovDens <- mats$matCov / nrow(vals)
###--- Prepare existing sample data ---###
#--- extract covariates at existing sample locations ---#
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
#--- Assign code to differentiate between original samples and those added during HELS algorithm ---#
samples$type <- "existing"
#--- Create data hypercube of existing samples to compare with mraster data ---#
matCovSamp <- mat_cov(vals = samples[3:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
#--- Change 0's to very small number to avoid division issues ---#
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovSampDens <- matCovSamp / nrow(samples)
###--- Selection of new samples based on density ---###
#--- Ratio and ordering of data density and covariate density ---#
ratio <- matCovSampDens / matCovDens
ratio
notRep <- which(ratio < 1, arr.ind = TRUE)
notRep
notRep <- cbind(notRep,which(ratio < 1))
notRep
ratio
ratOrder <- order(ratio)
ratOrder
overRep <- which(ratio > 1, arr.ind = TRUE)
overRep <- cbind(notRep,which(ratio > 1))
overRep <- which(ratio > 1, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio > 1))
overRep
overRep <- which(ratio > 2, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio > 1))
overRep <- which(ratio > 2, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio > 2))
overRep
overRep <- which(ratio > 2, arr.ind = TRUE)
overRep
overRep <- cbind(overRep,which(ratio > 2))
overRep
ratio
ratOrder
ratio
ratOrder
ratOrder
ratOrder[1]
notRep[,3]
repRank
which(notRep[,3] == ratOrder[1])
ratOrder[1]
ratio <- matCovSampDens / matCovDens
overRep <- which(ratio > 2, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio > 2))
overRep
ratio
ratOrder <- order(ratio)
ratOrder
rev(ratOrder)
ratio
overRep <- which(ratio > 1, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio > 1))
overRep
repRank <- which(underRep[,3] == ratOrder[1])
repRow <- underRep[repRank,1]
repcol <- underRep[repRank,2]
ratOrder <- order(ratio)
ratOrderRev <- rev(ratOrder)
underRep <- which(ratio < 1, arr.ind = TRUE)
underRep <- cbind(underRep,which(ratio < 1))
overRep <- which(ratio > 1, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio > 1))
newSamp <- nSamp
position <- 1
repRank <- which(underRep[,3] == ratOrder[1])
repRow <- underRep[repRank,1]
repcol <- underRep[repRank,2]
sampExist <- floor(nrow(samples) * matCovSampDens[repRow,repcol])
sampExist
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repcol])
sampOptim
which(overRep[,3] == ratOrderRev[1])
repRankOvder <- which(overRep[,3] == ratOrderOver[1])
ratOrderOver <- rev(ratOrder)
ratio <- matCovSampDens / matCovDens
ratOrderUnder <- order(ratio)
ratOrderUnder <- order(ratio)
ratOrderOver <- rev(ratOrderUnder)
repRankUnder <- which(underRep[,3] == ratOrderUnder[1])
repRow <- repRankUnder[repRankUnder,1]
repcol <- repRankUnder[repRankUnder,2]
sampExist <- floor(nrow(samples) * matCovSampDens[repRow,repcol])
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repcol])
ratOrderUnder
underRep
repRankUnder <- which(underRep[,3] == ratOrderUnder[1])
repRow <- repRankUnder[repRankUnder,1]
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
matCovSampDens <- matCovSamp / nrow(samples)
ratio <- matCovSampDens / matCovDens
ratOrderUnder <- order(ratio)
ratOrderOver <- rev(ratOrderUnder)
underRep <- which(ratio < 1, arr.ind = TRUE)
underRep <- cbind(underRep,which(ratio < 1))
overRep <- which(ratio > 1, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio > 1))
newSamp <- nSamp
position <- 1
repRankUnder <- which(underRep[,3] == ratOrderUnder[1])
repRankUnder
repRankUnder <- which(underRep[,3] == ratOrderUnder[1])
repRankUnder
ratOrderUnder
repRankUnder <- which(underRep[,3] == ratOrderUnder[1])
repRow <- repRankUnder[repRankUnder,1]
repRow <- underRep[repRankUnder,1]
repcol <- underRep[repRankUnder,2]
repRow
repcol
repRankUnder <- which(underRep[,3] == ratOrderUnder[1])
repRow <- underRep[repRankUnder,1]
repcol <- underRep[repRankUnder,2]
sampExist <- floor(nrow(samples) * matCovSampDens[repRow,repcol])
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repcol])
sampNeed <- sampOptim - sampExist
sampNeed
w
if(newSamp < sampNeed) sampNeed <- newSamp
sampNeed
repRowOver <- overRep[repRankOver,1]
repRankOver
repRankOver <- which(overRep[,3] == ratOrderOver[1])
repRowOver <- overRep[repRankOver,1]
repcolOver <- overRep[repRankOver,2]
repRowOver
repcolOver
covLowerOver <- mats$matQ[repRowOver,repcolOver]
covUpperOver <- mats$matQ[repRowOver + 1,repcolOver]
covLowerOver
covUpperOver
valsSub <- vals[vals[,(2 + repcolOver)] >= covLowerOver & vals[,(2 + repcolOver)] <= covUpperOver,]
valsSub
vals
repcolOver
samplesSub <- samples[samples[,(2 + repcolOver)] >= covLowerOver & vals[,(2 + repcolOver)] <= covUpperOver,]
samples
samples[,(2 + repcolOver)]
samples[,(2 + repcolOver)] >= covLowerOver
samples[,(2 + repcolOver)] >= covLowerOver & vals[,(2 + repcolOver)] <= covUpperOver
samples[samples[,(2 + repcolOver)] >= covLowerOver & vals[,(2 + repcolOver)] <= covUpperOver,]
samples
covUpperOver
covLowerOver
repcolOver
mats
samplesSub <- samples[samples[,(2 + repcolOver)] >= covLowerOver & vals[,(2 + repcolOver)] <= covUpperOver,]
samples
samples[,(2 + repcolOver)] >= covLowerOver & vals[,(2 + repcolOver)] <= covUpperOver
repRankOver
repRowOver <- overRep[repRankOver,1]
repRowOver
repcolOver <- overRep[repRankOver,2]
repcolOver
mats$matQ[repRowOver,repcolOver]
mats$matQ[repRowOver + 1,repcolOver]
samples[,(2 + repcolOver)] >= covLowerOver
samples[samples[,(2 + repcolOver)] >= covLowerOver & samples[,(2 + repcolOver)] <= covUpperOver,]
load_all()
analyze_HELS(mraster,existing,plot = TRUE)
repRankUnder <- which(underRep[,3] == ratOrderUnder[position])
repRow <- underRep[repRankUnder,1]
repcol <- underRep[repRankUnder,2]
sampExist <- floor(nrow(samples) * matCovSampDens[repRow,repcol])
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repcol])
sampNeed <- sampOptim - sampExist
if(newSamp < sampNeed) sampNeed <- newSamp
covLower <- mats$matQ[repRow,repCol]
repRow
repCol
nb <- terra::nlyr(mraster[[1:3]])
#--- determine crs of input sraster ---#
crs <- crs(mraster)
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE) %>%
dplyr::rename(X = x,
Y = y)
vals <- vals %>%
dplyr::filter(complete.cases(.))
mats <- analyze_popLHC(mraster = mraster[[1:3]],PCA = FALSE, nQuant = nQuant)
mats$matCov[which(mats$matCov == 0)] <- 0.0000001
matCovDens <- mats$matCov / nrow(vals)
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
samples$type <- "existing"
matCovSamp <- mat_cov(vals = samples[3:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
matCovSampDens <- matCovSamp / nrow(samples)
ratio <- matCovSampDens / matCovDens
ratOrderUnder <- order(ratio)
ratOrderOver <- rev(ratOrderUnder)
underRep <- which(ratio < 1, arr.ind = TRUE)
underRep <- cbind(underRep,which(ratio < 1))
overRep <- which(ratio > 1, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio > 1))
newSamp <- nSamp
position <- 1
while(newSamp > 0){
#--- determine the greatest discrepancy between sample and covariate data ---#
repRankUnder <- which(underRep[,3] == ratOrderUnder[position])
#--- determine row and column of most under represented quantile ---#
repRow <- underRep[repRankUnder,1]
repcol <- underRep[repRankUnder,2]
#--- determine number of existing samples in selected quantile ---#
sampExist <- floor(nrow(samples) * matCovSampDens[repRow,repcol])
#--- determine max number of samples based on covariate density ---#
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repcol])
#--- number of samples needed ---#
sampNeed <- sampOptim - sampExist
#--- we have a limited number of samples so we need to be sure not to over allocate ---#
if(newSamp < sampNeed) sampNeed <- newSamp
#--- selecting covariates based on quantile chosen ---#
covLower <- mats$matQ[repRow,repCol]
covUpper <- mats$matQ[repRow + 1,repCol]
#--- subset covariate dataset for potential new samples ---#
valsSub <- vals[vals[,(2 + repCol)] >= covLower & vals[,(2 + repCol)] <= covUpper,]
#--- randomly sample within valsSub and extract randomly sampled cells ---#
addSamp <- sample(nrow(valsSub), sampNeed)
valsSubSamp <- valsSub[addSamp,]
valsSubSamp$type <- "new"
#--- remove samples from pool to ensure same cells are not sampled again ---#
vals <- vals[-addSamp,]
#--- add new samples to existing sample dataframe ---#
samples <- rbind(samples,valsSubSamp)
#--- update loop parameters ---#
position <- position + 1
newSamp <- newSamp - sampNeed
print(sampNeed)
}
repRankUnder <- which(underRep[,3] == ratOrderUnder[position])
repRankUnder
repRow <- underRep[repRankUnder,1]
repcol <- underRep[repRankUnder,2]
repRow
repcol
sampExist <- floor(nrow(samples) * matCovSampDens[repRow,repcol])
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repcol])
sampNeed <- sampOptim - sampExist
if(newSamp < sampNeed) sampNeed <- newSamp
sampNeed
covLower <- mats$matQ[repRow,repCol]
mats$matQ
repRow
repCol
load_all()
analyze_HELS(mraster,existing,plot = TRUE)
#--- determine number of bands in 'mraster' ---#
nb <- terra::nlyr(mraster)
#--- determine crs of input sraster ---#
crs <- crs(mraster)
#--- extract covariates data from mraster ---#
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE) %>%
dplyr::rename(X = x,
Y = y)
#--- Remove NA / NaN / Inf values ---#
vals <- vals %>%
dplyr::filter(complete.cases(.))
#--- Generate quantile matrix ---#
mats <- analyze_popLHC(mraster = mraster,PCA = FALSE, nQuant = nQuant)
#--- Change 0's to very small number to avoid division issues ---#
mats$matCov[which(mats$matCov == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovDens <- mats$matCov / nrow(vals)
###--- Prepare existing sample data ---###
#--- extract covariates at existing sample locations ---#
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
#--- Assign code to differentiate between original samples and those added during HELS algorithm ---#
samples$type <- "existing"
#--- Create data hypercube of existing samples to compare with mraster data ---#
matCovSamp <- mat_cov(vals = samples[3:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
#--- Change 0's to very small number to avoid division issues ---#
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovSampDens <- matCovSamp / nrow(samples)
###--- Selection of new samples based on density ---###
#--- Ratio and ordering of data density and covariate density ---#
ratio <- matCovSampDens / matCovDens
#--- order the densities based on representation ---#
#--- low to high ---#
ratOrderUnder <- order(ratio)
#--- high to low ---#
ratOrderOver <- rev(ratOrderUnder)
#--- Outline quantiles that are underrepresented (< 1) in the sample ---#
underRep <- which(ratio < 1, arr.ind = TRUE)
underRep <- cbind(underRep,which(ratio < 1))
#--- Outline quantiles that are overrepresented (> 1) in the sample ---#
overRep <- which(ratio > 1, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio > 1))
#--- begin sampling from highest discrepancy to lowest ---#
newSamp <- nSamp
position <- 1
#--- begin while loop to sample ---#
while(newSamp > 0){
#--- determine the greatest discrepancy between sample and covariate data ---#
repRankUnder <- which(underRep[,3] == ratOrderUnder[position])
#--- determine row and column of most under represented quantile ---#
repRow <- underRep[repRankUnder,1]
repcol <- underRep[repRankUnder,2]
#--- determine number of existing samples in selected quantile ---#
sampExist <- floor(nrow(samples) * matCovSampDens[repRow,repcol])
#--- determine max number of samples based on covariate density ---#
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repcol])
#--- number of samples needed ---#
sampNeed <- sampOptim - sampExist
#--- we have a limited number of samples so we need to be sure not to over allocate ---#
if(newSamp < sampNeed) sampNeed <- newSamp
#--- selecting covariates based on quantile chosen ---#
covLower <- mats$matQ[repRow,repCol]
covUpper <- mats$matQ[repRow + 1,repCol]
#--- subset covariate dataset for potential new samples ---#
valsSub <- vals[vals[,(2 + repCol)] >= covLower & vals[,(2 + repCol)] <= covUpper,]
#--- randomly sample within valsSub and extract randomly sampled cells ---#
addSamp <- sample(nrow(valsSub), sampNeed)
valsSubSamp <- valsSub[addSamp,]
valsSubSamp$type <- "new"
#--- remove samples from pool to ensure same cells are not sampled again ---#
vals <- vals[-addSamp,]
#--- add new samples to existing sample dataframe ---#
samples <- rbind(samples,valsSubSamp)
#--- update loop parameters ---#
position <- position + 1
newSamp <- newSamp - sampNeed
print(sampNeed)
}
#--- Create data hypercube of existing samples to compare with mraster data ---#
matCovSamp <- mat_cov(vals = samples[3:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
#--- Change 0's to very small number to avoid division issues ---#
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovSampDens <- matCovSamp / nrow(samples)
###--- Selection of new samples based on density ---###
#--- Ratio and ordering of data density and covariate density ---#
ratio <- matCovSampDens / matCovDens
ratio
load_all()
analyze_HELS(mraster[[1:3]],existing,plot = TRUE)
mraster <- mraster[[1:3]]
nb <- terra::nlyr(mraster)
#--- determine crs of input sraster ---#
crs <- crs(mraster)
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE) %>%
dplyr::rename(X = x,
Y = y)
vals <- vals %>%
dplyr::filter(complete.cases(.))
mats <- analyze_popLHC(mraster = mraster,PCA = FALSE, nQuant = nQuant)
mats$matCov[which(mats$matCov == 0)] <- 0.0000001
matCovDens <- mats$matCov / nrow(vals)
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
samples$type <- "existing"
matCovSamp <- mat_cov(vals = samples[3:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
matCovSampDens <- matCovSamp / nrow(samples)
ratio <- matCovSampDens / matCovDens
ratOrderUnder <- order(ratio)
ratOrderOver <- rev(ratOrderUnder)
underRep <- which(ratio < 1, arr.ind = TRUE)
underRep <- cbind(underRep,which(ratio < 1))
overRep <- which(ratio > 1, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio > 1))
newSamp <- nSamp
position <- 1
repRankUnder <- which(underRep[,3] == ratOrderUnder[position])
repRankUnder
repRow <- underRep[repRankUnder,1]
repcol <- underRep[repRankUnder,2]
sampExist <- floor(nrow(samples) * matCovSampDens[repRow,repcol])
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repcol])
sampNeed <- sampOptim - sampExist
if(newSamp < sampNeed) sampNeed <- newSamp
covLower <- mats$matQ[repRow,repCol]
mats$matQ
repRow
repCol
underRep
underRep[repRankUnder,2]
repCol <- underRep[repRankUnder,2]
repCol
load_all()
analyze_HELS(mraster[[1:3]],existing,plot = TRUE)
