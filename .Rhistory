k <- reshape2::melt(ratio1, c("y", "x"), value.name = "z") %>%
dplyr::filter(complete.cases(.))
k$type <- "pre"
k1 <- reshape2::melt(ratio1_, c("y", "x"), value.name = "z") %>%
dplyr::filter(complete.cases(.))
k1$type <- "post"
k2 <- reshape2::melt(rdiff, c("y", "x"), value.name = "z") %>%
dplyr::filter(complete.cases(.))
k2$type <- "diff"
kk <- rbind(k,k1)
ggplot(kk, aes(x=x, y=y, fill = z)) + geom_tile(colour = "grey50") +  scale_fill_viridis() + facet_grid(.~type)
library(viridis)
ggplot(kk, aes(x=x, y=y, fill = z)) + geom_tile(colour = "grey50") +  scale_fill_viridis() + facet_grid(.~type)
mraster <- mraster[[1:3]]
nb <- terra::nlyr(mraster)
#--- determine crs of input sraster ---#
crs <- crs(mraster)
#--- extract covariates data from mraster ---#
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE) %>%
dplyr::rename(X = x,
Y = y)
#--- Remove NA / NaN / Inf values ---#
vals <- vals %>%
dplyr::filter(complete.cases(.))
#--- Generate quantile matrix ---#
mats <- analyze_popLHC(mraster = mraster,PCA = FALSE, nQuant = nQuant)
#--- Change 0's to very small number to avoid division issues ---#
mats$matCov[which(mats$matCov == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovDens <- mats$matCov / nrow(vals)
#--- Remove quantiles that do not cover at least 1% area in eac covariate ---#
matCovDens[which(matCovDens <= 0.01)] <- NA
###--- Prepare existing sample data ---###
#--- extract covariates at existing sample locations ---#
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
#--- Assign code to differentiate between original samples and those added during HELS algorithm ---#
samples$type <- "existing"
samples$n <- seq(1:nrow(samples))
#--- Rearrange columns ---#
samples <- samples %>%
select(X,Y,n,type,everything())
#--- Create data hypercube of existing samples to compare with mraster data ---#
matCovSamp <- mat_cov(vals = samples[5:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
#--- Change 0's to very small number to avoid division issues ---#
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovSampDens <- matCovSamp / nrow(samples)
###--- Selection of new samples based on density ---###
#--- Ratio and ordering of data density and covariate density ---#
ratio1 <- matCovSampDens / matCovDens
#--- OUtline which quantiles are greater than 1 (overrepresented) ---#
ratioGr1 <- ratio1 > 1
#--- set NA values to FALSE -- these are from quantiles with <= 1% of covariate coverage ---#
ratioGr1[is.na(ratioGr1)] <- FALSE
#--- Generate dataframe where quantiles that are TRUE in ratioGr1 are compared ---#
#--- indexOverRep will be used to interatively remove samples starting from the most overrepresented quantile in the sample data (Subject) ---#
#--- The subject will then be compared to overrepresented quantiles in all other covariates (Subject) to narrow down where samples should be prioritied to be removed ---#
#--- create empty dataframe to be populated ---#
indexOverRep <- data.frame()
#--- iterate through each row and column ---#
for(i in 1:nrow(ratioGr1)){
for(j in 1:ncol(ratioGr1)){
#--- SUBJECT - process when TRUE ---#
if(isTRUE(ratioGr1[i,j])){
#--- Do not compare quantiles from the same variable ---#
for(ii in 1:nrow(ratioGr1)){
for(jj in 1:ncol(ratioGr1)){
#--- OBJECT - if the 2 quantiles share the same column - go next ---#
if(jj == j) next
#--- if the Subject == TRUE and Object == TRUE ---#
if(isTRUE(ratioGr1[ii,jj])){
#--- Determine overrepresented quantile range ---#
covLower <- mats$matQ[ii, jj]
covUpper <- mats$matQ[ii + 1, jj]
#--- Populate dataframe listing the subject quantile (rowSub, colSub) and object quantile (rowObj, colObj) and associated OBJECT quantile ranges ---#
df <- data.frame(rowSub = i, colSub = j, rowObj = ii, colObj = jj, covLower = covLower, covUpper = covUpper)
#--- Rbind the dataframe together to create a comprensive comparative list of overrepresented quantiles ---#
indexOverRep <- rbind(df,indexOverRep)
} else {
#--- if FALSE - go next ---#
next
}
}
}
} else {
#--- if FALSE - go next ---#
next
}
}
}
#--- order the densities based on representation ---#
#--- low to high ---#
ratOrderUnder <- order(ratio1,na.last = NA)
#--- high to low ---#
ratOrderOver <- rev(ratOrderUnder)
#--- Outline quantiles that are overrepresented (> 1) in the sample ---#
overRep <- which(ratio1 > 1, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio1 > 1))
#--- determine decending order of overrepresentation ---#
indexOrder <- overRep %>%
as.data.frame() %>%
dplyr::rename(order = V3) %>%
dplyr::arrange(match(order,ratOrderOver[1:nrow(overRep)])) %>%
tidyr::unite(uniteObj, c("row","col"), remove = FALSE)
#--- looping parameters ---#
objRank <- 1
samplesNew <- samples
while(objRank <= nrow(overRep)){
#--- determine row and column of most over represented quantile ---#
repRow <- indexOrder[objRank,]$row
repCol <- indexOrder[objRank,]$col
#--- determine optimum number of samples based on covariate density ---#
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repCol])
#--- select covariates based on quantile chosen ---#
covLower <- mats$matQ[repRow,repCol]
covUpper <- mats$matQ[repRow + 1,repCol]
#--- create subject level subset of overrepresented samples ---#
sub <- samplesNew %>%
dplyr::filter(.[,(4 + repCol)] >= covLower & .[,(4 + repCol)] <= covUpper)
#--- Total number of sample matching subject quantile criteria ---#
sampTot <- nrow(sub)
#--- difference between optimal sample number and total samples meeting subject criteria ---#
sampDiff <- abs(sampOptim - sampTot)
#--- Subset indexOverRep to match subject criteria and arrange in order of descending overrepresentation of object quantiles ---#
indexOverRepSub <- indexOverRep %>%
dplyr::filter(rowSub == repRow & colSub == repCol) %>%
tidyr::unite(uniteObj, c("rowObj","colObj"), remove = FALSE) %>%
dplyr::arrange(match(uniteObj,indexOrder$uniteObj))
#--- loop interator to stop after subject / object pairings have been exhausted ---#
subRank <- 1
#--- Removal of samples loop ---#
#--- Continue until ---#
#--- 1) the sampDiff value has reached 0 (optimal sample number for subject quantile has been reached) ---#
#--- 2) the subject / object pairings have been exhausted ---#
#--- Samples that meet criteria will have $type set to "retired" ---#
while(sampDiff > 0 && subRank <= nrow(indexOverRepSub)){
for(i in 1:nrow(indexOverRepSub)){
#--- update object order rank ---#
subRank <- subRank + 1
#--- create object level subset of overrepresented samples ---#
subObj <- sub %>%
dplyr::filter(type != "retired") %>%
dplyr::filter(.[,(4 + indexOverRepSub$colObj[i])] >= indexOverRepSub$covLower[i] & .[,(4 + indexOverRepSub$colObj[i])] <= indexOverRepSub$covUpper[i])
#--- potential number of samples that can be retired ---#
nRet <- nrow(subObj)
#--- If there are no samples that match criteria - go next ---#
if(nRet == 0) next
#--- If the nRet > sampDiff - take the remaining number of samples to be removed ---#
if(nRet > sampDiff){
samplesNew <- subObj %>%
dplyr::slice(sampDiff) %>%
dplyr::mutate(type = "retired") %>%
dplyr::rows_update(samplesNew, ., by= "n")
#--- If sampDiff > nRet remove all samples available ---#
} else {
samplesNew <- subObj %>%
dplyr::mutate(type = "retired") %>%
dplyr::rows_update(samplesNew, ., by= "n")
}
#--- Update sampDiff iterator to reflect retirement of samples ---#
sampDiff <- sampDiff - nRet
}
}
#--- Update Subject order rank ---#
objRank <- objRank + 1
}
#--- determine the difference im representation for quantiles ---#
#--- filter our all retired samples ---#
samples_ <- samplesNew %>% dplyr::filter(type != "retired")
matCovSamp_ <- mat_cov(vals = samples_[5:ncol(samples_)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
#--- Change 0's to very small number to avoid division issues ---#
matCovSamp_[which(matCovSamp_ == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovSampDens_ <- matCovSamp_ / nrow(samples_)
###--- Selection of new samples based on density ---###
#--- Ratio and ordering of data density and covariate density ---#
ratio1_ <- matCovSampDens_ / matCovDens
rdiff <- ratio1_ - ratio1
# par(mfrow=c(1,3))
# par(mar=c(5.1, 4.1, 4.1, 4.1))
#
# plot(ratio1, breaks=range(ratio1_,na.rm=TRUE), col=topo.colors, main = "Original Data", asp=TRUE, axis.col=NULL, axis.row=NULL, xlab='', ylab='')
# plot(ratio1_, breaks=range(ratio1_,na.rm=TRUE), col=topo.colors, main = "Reduced Data", asp=TRUE, axis.col=NULL, axis.row=NULL, xlab='', ylab='')
# plot(rdiff, breaks=range(rdiff,na.rm=TRUE), col=topo.colors, main = "Difference", asp=TRUE, axis.col=NULL, axis.row=NULL, xlab='', ylab='')
k <- reshape2::melt(ratio1, c("y", "x"), value.name = "z") %>%
dplyr::filter(complete.cases(.))
k$type <- "pre"
k1 <- reshape2::melt(ratio1_, c("y", "x"), value.name = "z") %>%
dplyr::filter(complete.cases(.))
k1$type <- "post"
k2 <- reshape2::melt(rdiff, c("y", "x"), value.name = "z") %>%
dplyr::filter(complete.cases(.))
k2$type <- "diff"
kk <- rbind(k,k1)
ggplot(kk, aes(x=x, y=y, fill = z)) + geom_tile(colour = "grey50") +  scale_fill_viridis() + facet_grid(.~type)
ratio1
ratio1_
#--- define desired stratification raster ---#
sraster <- kmeans
#--- 'mindist' between samples defaults to 100 ---#
existing <- sample_srs(sraster = sraster, #srs_wo
n = 300,
plot = TRUE)
sraster
kmeans
#--- perform stratification using k-means ---#
kmeans <- strat_kmeans(mraster = wall_poly[[1]], nstrata = 4)
plot(kmeans)
#--- set 'details' = TRUE to get algorithm details and outputs ---#
#--- define desired stratification raster ---#
sraster <- kmeans
#--- SRS **without** access defined---#
#--- 'mindist' between samples defaults to 100 ---#
existing <- sample_srs(sraster = sraster, #srs_wo
n = 300,
plot = TRUE)
#--- determine number of bands in 'mraster' ---#
nb <- terra::nlyr(mraster)
#--- determine crs of input sraster ---#
crs <- crs(mraster)
#--- extract covariates data from mraster ---#
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE) %>%
dplyr::rename(X = x,
Y = y)
#--- Remove NA / NaN / Inf values ---#
vals <- vals %>%
dplyr::filter(complete.cases(.))
#--- Generate quantile matrix ---#
mats <- analyze_popLHC(mraster = mraster,PCA = FALSE, nQuant = nQuant)
#--- Change 0's to very small number to avoid division issues ---#
mats$matCov[which(mats$matCov == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovDens <- mats$matCov / nrow(vals)
#--- Remove quantiles that do not cover at least 1% area in eac covariate ---#
matCovDens[which(matCovDens <= 0.01)] <- NA
###--- Prepare existing sample data ---###
#--- extract covariates at existing sample locations ---#
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
#--- Assign code to differentiate between original samples and those added during HELS algorithm ---#
samples$type <- "existing"
samples$n <- seq(1:nrow(samples))
#--- Rearrange columns ---#
samples <- samples %>%
select(X,Y,n,type,everything())
#--- Create data hypercube of existing samples to compare with mraster data ---#
matCovSamp <- mat_cov(vals = samples[5:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
#--- Change 0's to very small number to avoid division issues ---#
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
#--- Create density matrix from covariates and length of mraster ---#
matCovSampDens <- matCovSamp / nrow(samples)
samples
matCovSamp <- mat_cov(vals = samples[5:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
matCovSampDens <- matCovSamp / nrow(samples)
ratio1 <- matCovSampDens / matCovDens
ratioGr1 <- ratio1 > 1
ratioGr1[is.na(ratioGr1)] <- FALSE
indexOverRep <- data.frame()
samples
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
samples$type <- "existing"
samples$n <- seq(1:nrow(samples))
samples <- samples %>%
select(X,Y,n,type,everything())
samples %>%
dplyr::select(X,Y,n,type,everything())
samples <- samples %>%
dplyr::select(X,Y,n,type,everything())
matCovSamp <- mat_cov(vals = samples[5:ncol(samples)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
matCovSamp[which(matCovSamp == 0)] <- 0.0000001
matCovSampDens <- matCovSamp / nrow(samples)
ratio1 <- matCovSampDens / matCovDens
ratioGr1 <- ratio1 > 1
ratioGr1[is.na(ratioGr1)] <- FALSE
indexOverRep <- data.frame()
for(i in 1:nrow(ratioGr1)){
for(j in 1:ncol(ratioGr1)){
#--- SUBJECT - process when TRUE ---#
if(isTRUE(ratioGr1[i,j])){
#--- Do not compare quantiles from the same variable ---#
for(ii in 1:nrow(ratioGr1)){
for(jj in 1:ncol(ratioGr1)){
#--- OBJECT - if the 2 quantiles share the same column - go next ---#
if(jj == j) next
#--- if the Subject == TRUE and Object == TRUE ---#
if(isTRUE(ratioGr1[ii,jj])){
#--- Determine overrepresented quantile range ---#
covLower <- mats$matQ[ii, jj]
covUpper <- mats$matQ[ii + 1, jj]
#--- Populate dataframe listing the subject quantile (rowSub, colSub) and object quantile (rowObj, colObj) and associated OBJECT quantile ranges ---#
df <- data.frame(rowSub = i, colSub = j, rowObj = ii, colObj = jj, covLower = covLower, covUpper = covUpper)
#--- Rbind the dataframe together to create a comprensive comparative list of overrepresented quantiles ---#
indexOverRep <- rbind(df,indexOverRep)
} else {
#--- if FALSE - go next ---#
next
}
}
}
} else {
#--- if FALSE - go next ---#
next
}
}
}
ratOrderUnder <- order(ratio1,na.last = NA)
ratOrderOver <- rev(ratOrderUnder)
overRep <- which(ratio1 > 1, arr.ind = TRUE)
overRep <- cbind(overRep,which(ratio1 > 1))
indexOrder <- overRep %>%
as.data.frame() %>%
dplyr::rename(order = V3) %>%
dplyr::arrange(match(order,ratOrderOver[1:nrow(overRep)])) %>%
tidyr::unite(uniteObj, c("row","col"), remove = FALSE)
objRank <- 1
samplesNew <- samples
while(objRank <= nrow(overRep)){
#--- determine row and column of most over represented quantile ---#
repRow <- indexOrder[objRank,]$row
repCol <- indexOrder[objRank,]$col
#--- determine optimum number of samples based on covariate density ---#
sampOptim <- ceiling(nrow(samples) * matCovDens[repRow,repCol])
#--- select covariates based on quantile chosen ---#
covLower <- mats$matQ[repRow,repCol]
covUpper <- mats$matQ[repRow + 1,repCol]
#--- create subject level subset of overrepresented samples ---#
sub <- samplesNew %>%
dplyr::filter(.[,(4 + repCol)] >= covLower & .[,(4 + repCol)] <= covUpper)
#--- Total number of sample matching subject quantile criteria ---#
sampTot <- nrow(sub)
#--- difference between optimal sample number and total samples meeting subject criteria ---#
sampDiff <- abs(sampOptim - sampTot)
#--- Subset indexOverRep to match subject criteria and arrange in order of descending overrepresentation of object quantiles ---#
indexOverRepSub <- indexOverRep %>%
dplyr::filter(rowSub == repRow & colSub == repCol) %>%
tidyr::unite(uniteObj, c("rowObj","colObj"), remove = FALSE) %>%
dplyr::arrange(match(uniteObj,indexOrder$uniteObj))
#--- loop interator to stop after subject / object pairings have been exhausted ---#
subRank <- 1
#--- Removal of samples loop ---#
#--- Continue until ---#
#--- 1) the sampDiff value has reached 0 (optimal sample number for subject quantile has been reached) ---#
#--- 2) the subject / object pairings have been exhausted ---#
#--- Samples that meet criteria will have $type set to "retired" ---#
while(sampDiff > 0 && subRank <= nrow(indexOverRepSub)){
for(i in 1:nrow(indexOverRepSub)){
#--- update object order rank ---#
subRank <- subRank + 1
#--- create object level subset of overrepresented samples ---#
subObj <- sub %>%
dplyr::filter(type != "retired") %>%
dplyr::filter(.[,(4 + indexOverRepSub$colObj[i])] >= indexOverRepSub$covLower[i] & .[,(4 + indexOverRepSub$colObj[i])] <= indexOverRepSub$covUpper[i])
#--- potential number of samples that can be retired ---#
nRet <- nrow(subObj)
#--- If there are no samples that match criteria - go next ---#
if(nRet == 0) next
#--- If the nRet > sampDiff - take the remaining number of samples to be removed ---#
if(nRet > sampDiff){
samplesNew <- subObj %>%
dplyr::slice(sampDiff) %>%
dplyr::mutate(type = "retired") %>%
dplyr::rows_update(samplesNew, ., by= "n")
#--- If sampDiff > nRet remove all samples available ---#
} else {
samplesNew <- subObj %>%
dplyr::mutate(type = "retired") %>%
dplyr::rows_update(samplesNew, ., by= "n")
}
#--- Update sampDiff iterator to reflect retirement of samples ---#
sampDiff <- sampDiff - nRet
}
}
#--- Update Subject order rank ---#
objRank <- objRank + 1
}
samplesNew
#--- filter our all retired samples ---#
samples_ <- samplesNew %>% dplyr::filter(type != "retired")
matCovSamp_ <- mat_cov(vals = samples_[5:ncol(samples_)], nQuant = nQuant, nb = nb, matQ = mats$matQ)
matCovSamp_[which(matCovSamp_ == 0)] <- 0.0000001
matCovSampDens_ <- matCovSamp_ / nrow(samples_)
ratio1_ <- matCovSampDens_ / matCovDens
rdiff <- ratio1_ - ratio1
k <- reshape2::melt(ratio1, c("y", "x"), value.name = "z") %>%
dplyr::filter(complete.cases(.))
k$type <- "pre"
k1 <- reshape2::melt(ratio1_, c("y", "x"), value.name = "z") %>%
dplyr::filter(complete.cases(.))
k1$type <- "post"
k2 <- reshape2::melt(rdiff, c("y", "x"), value.name = "z") %>%
dplyr::filter(complete.cases(.))
k2$type <- "diff"
kk <- rbind(k,k1)
ggplot(kk, aes(x=x, y=y, fill = z)) + geom_tile(colour = "grey50") +  scale_fill_viridis() + facet_grid(.~type)
mats$matQ
rdiff
ratio1_
ratio1
ratio1_
ggplot(kk, aes(x=x, y=y, fill = z)) + geom_tile(colour = "grey50") +  scale_colour_brewer(palette = "RdYlBu") + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y, fill = z)) + geom_tile(colour = "grey50") + scale_colour_brewer(palette = "Greens") + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y, fill = z)) + scale_colour_brewer(palette = "Greens") + geom_tile(colour = "grey50") + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y, colour = z)) + scale_colour_brewer(palette = "Greens")
ggplot(kk, aes(x=x, y=y, colour = z)) + scale_colour_brewer(type = "div", palette = "Greens") + geom_tile(colour = "grey50") + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y, colour = z)) + scale_colour_brewer(type = "div") + geom_tile(colour = "grey50") + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y, fill = z)) + scale_colour_brewer(type = "div") + geom_tile(colour = "grey50") + facet_grid(.~type)
class(kk$z)
kk
ggplot(kk, aes(x=x, y=y, colour = z)) + scale_colour_gradient2() + geom_tile(colour = "grey50") + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y, fill = z)) + scale_colour_gradient2() + geom_tile(colour = "grey50") + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y)) + geom_tile(aes(colour = "z")) + scale_colour_gradient2() + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y)) + geom_tile(aes(colour = "z"))
ggplot(kk, aes(x=x, y=y)) + geom_tile(aes(fill = "z"))
ggplot(kk, aes(x=x, y=y)) + geom_tile(aes(fill = z)) + scale_colour_gradient2() + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y)) + geom_tile(aes(colour = z)) + scale_colour_gradient2() + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y, fill = z)) + geom_tile() + scale_colour_gradient2() + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y)) + geom_tile(fill = z) + scale_colour_gradient2() + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y)) + geom_tile(aes(fill = z)) + scale_colour_gradient2() + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y)) + geom_tile(aes(fill = z), colour = "grey50") + scale_colour_gradient2() + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y)) + geom_tile(colour = "grey50") + scale_colour_gradient2() + facet_grid(.~type)
ggplot(kk, aes(x=x, y=y)) + geom_tile(aes(fill = z), colour = "grey50") +
scale_fill_continuous_divergingx(palette = 'RdBu', mid = 0.7) + facet_grid(.~type)
install.packages("colorspace")
install.packages("colorspace")
install.packages("colorspace")
#--- convert vectors to spatVector to synergize with terra raster functions---#
roads <- terra::vect(roads)
buff_in <- terra::buffer(x = roads,
width = 50)
t <- terra::rasterize(buff_in,mraster[[1]])
mmm <- mask(x = mraster[[1]], mask = t, inverse = TRUE)
library(devtools)
load_all(])
load_all()
#--- convert vectors to spatVector to synergize with terra raster functions---#
roads <- terra::vect(roads)
buff_in <- terra::buffer(x = roads,
width = 50)
t <- terra::rasterize(buff_in,mraster[[1]])
mraster
library(sgsR)
library(terra)
library(sf)
library(RColorBrewer)
library(dplyr)
library(tidyr)
library(ggplot2)
library(spatstat)
#--- import ALS metrics raster ---#
raster <- "F:/_2021_SGS/sgsR/inst/extdata/rmf_metrics.tif" #system.file("extdata","rmf_metrics.tif", package = "sgsR")
mraster <- terra::rast(raster)
names(mraster) <- c("zmax","zmean","zsd","pzabove2","zq20","zq50","zq70","zq90","zq95","l_1","l_2","t_3","t_4")
#--- import forest inventory polygon and mask unwanted areas ---#
poly <- "F:/_2021_SGS/sgsR/inst/extdata/inventory_polygons.shp" #system.file("extdata","inventory_polygons.shp", package = "sgsR")
poly <- sf::st_read(poly)
#--- import access layer to be used during sampling if desired ---#
roads <- "F:/_2021_SGS/sgsR/inst/extdata/roads.shp" #system.file("extdata","roads.shp", package = "sgsR")
roads <- sf::st_read(roads)
#--- manipulate inventory polygon to mask out unwanted areas ---#
poly_subset <- poly[poly$POLYTYPE == "FOR" & poly$OWNER == 1, ]
poly_subset <- sf::st_union(poly_subset)
poly_subset <- terra::vect(poly_subset)
#--- mask input ALS raster using polygon layer ---#
wall_poly <- terra::mask(mraster,
poly_subset)
terra::plot(wall_poly[[1:2]])
#--- convert vectors to spatVector to synergize with terra raster functions---#
roads <- terra::vect(roads)
buff_in <- terra::buffer(x = roads,
width = 50)
t <- terra::rasterize(buff_in,mraster[[1]])
mmm <- mask(x = mraster[[1]], mask = t, inverse = TRUE)
mmm
plot(mmm)
#--- extract XY coordinates from raster ---#
vals <- terra::as.data.frame(wall_poly[[1:3]],xy=TRUE) %>%
dplyr::rename(X = x,
Y = y)
roads <- terra::vect(roads)
buff_in <- terra::buffer(x = roads,
width = 100)
kk <- terra::distance(mraster[[1]],roads)
plot(kk)
kk[which(kk <= 50)] <- NA
kk[kk <= 50] <- NA
plot(kk)
plot(t)
t <- terra::rasterize(buff_in,mraster[[1]])
kk <- terra::distance(mraster[[1]],roads)
kk[kk <= 50] <- NA
mmm <- mask(x = mraster[[1]], mask = t, inverse = TRUE)
plot(nnn)
plot(mmm)
buff_in <- terra::buffer(x = roads,
width = 50)
t <- terra::rasterize(buff_in,mraster[[1]])
mmm <- mask(x = mraster[[1]], mask = t, inverse = TRUE)
plot(mmm)
#--- convert vectors to spatVector to synergize with terra raster functions---#
roads <- terra::vect(roads)
buff_in <- terra::buffer(x = roads,
width = 50)
t <- terra::rasterize(buff_in,mraster[[1]])
mmm <- mask(x = mraster[[1]], mask = t, inverse = TRUE)
#--- extract XY coordinates from raster ---#
vals <- terra::as.data.frame(wall_poly[[1:3]],xy=TRUE) %>%
dplyr::rename(X = x,
Y = y)
kk.m <- mask(kk,wall_poly[[1]])
terra::as.data.frame(kk.m,xy=TRUE) %>%
dplyr::rename(X = x,
Y = y)
