plot = TRUE)
#--- define desired stratification raster ---#
sraster <- kmeans
#--- SRS **without** access defined---#
#--- 'mindist' between samples defaults to 100 ---#
srs_wo <- sample_srs(sraster = sraster,
n = 200,
plot = TRUE)
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE)
mraster <- wall_poly[[1:3]]
vals <- terra::as.data.frame(mraster,xy=TRUE)
vals[!is.finite(vals)] <- NA
class(vals)
vals
vals <- terra::as.data.frame(mraster, xy=TRUE, row.names = FALSE)
is.finite(vals)
vals <- terra::as.data.frame(mraster, xy=TRUE, row.names = FALSE)
vals[!is.finite(vals)] <- NA
vals
vals <- as.data.frame(vals)
vals[!is.finite(vals)] <- NA
load_all()
vals <- terra::as.data.frame(mraster, xy=TRUE, row.names = FALSE)
vals[!is.finite(vals)] <- NA
vals
class(vals)
library(terra)
xy <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals[!is.finite(vals)] <- NA
vals[,!is.finite(vals)] <- NA
is.finite(vals)
vals <- vals %>%
dplyr::filter(complete.cases(.))
vals
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals[!is.finite(vals)] <- NA
vals <- vals %>%
dplyr::filter(complete.cases(.))
vals
load_all()
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE)
use_package(doParallel)
use_package("doParallel",min_version = TRUE)
load_all()
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE)
use_package("parallel",min_version = TRUE)
load_all()
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE)
load_all()
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE)
use_package("foreach",min_version = TRUE)
??%dopar%
?%dopar%
load_all()
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE)
load_all()
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE)
document()
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE)
use_package("snow",min_version = TRUE)
document()
load_all()
document()
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE)
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE,cores=8)
load_all()
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo, plot = TRUE,cores=8)
#--- End parallel ---#
snow::stopCluster(cl)
#--- End parallel ---#
snow::stopCluster(cl)
stopCluster()
vals
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals <- terra::as.data.frame(wall_poly, xy = TRUE, row.names = FALSE)
library(sgsR)
library(terra)
library(sf)
library(RColorBrewer)
library(dplyr)
library(tidyr)
library(ggplot2)
library(spatstat)
#--- import ALS metrics raster ---#
raster <- system.file("extdata","rmf_metrics.tif", package = "sgsR")
raster <- terra::rast(raster)
library(sgsR)
library(terra)
library(sf)
library(RColorBrewer)
library(dplyr)
library(tidyr)
library(ggplot2)
library(spatstat)
#--- import ALS metrics raster ---#
raster <- system.file("extdata","rmf_metrics.tif", package = "sgsR")
raster <- terra::rast(raster)
library(sgsR)
library(terra)
library(sf)
library(RColorBrewer)
library(dplyr)
library(tidyr)
library(ggplot2)
library(spatstat)
#--- import ALS metrics raster ---#
raster <- system.file("extdata","rmf_metrics.tif", package = "sgsR")
raster <- terra::rast(raster)
library(devtools)
load_all()
#--- import ALS metrics raster ---#
raster <- system.file("extdata","rmf_metrics.tif", package = "sgsR")
raster <- terra::rast(raster)
names(raster) <- c("zmax","zmean","zsd","pzabove2","zq20","zq50","zq70","zq90","zq95","l_1","l_2","t_3","t_4")
#--- import forest inventory polygon and mask unwanted areas ---#
poly <- system.file("extdata","inventory_polygons.shp", package = "sgsR")
poly <- sf::st_read(poly)
#--- import access layer to be used during sampling if desired ---#
roads <- system.file("extdata","roads.shp", package = "sgsR")
roads <- sf::st_read(roads)
#--- manipulate inventory polygon to mask out unwanted areas ---#
poly_subset <- poly[poly$POLYTYPE == "FOR" & poly$OWNER == 1, ]
poly_subset <- sf::st_union(poly_subset)
poly_subset <- terra::vect(poly_subset)
#--- mask input ALS raster using polygon layer ---#
wall_poly <- terra::mask(raster,
poly_subset)
terra::plot(wall_poly[[1:2]])
#--- perform stratification using k-means ---#
kmeans <- strat_kmeans(mraster = wall_poly[[1]], nstrata = 4)
plot(kmeans)
#--- set 'details' = TRUE to get algorithm details and outputs ---#
#--- define desired stratification raster ---#
sraster <- kmeans
#--- SRS **without** access defined---#
#--- 'mindist' between samples defaults to 100 ---#
srs_wo <- sample_srs(sraster = sraster,
n = 200,
plot = TRUE)
mraster <- wall_poly
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals <- vals %>%
dplyr::filter(complete.cases(.))
vals
mraster <- wall_poly[[1:3]]
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals <- vals %>%
dplyr::filter(complete.cases(.))
vals
vals <- vals %>%
dplyr::filter(complete.cases(.))
covMat<- as.matrix(cov(vals))
samples <- extract_metrics(wall_poly, srs_wo, data.frame = TRUE)
samples
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals <- vals %>%
dplyr::filter(complete.cases(.))
covMat<- as.matrix(cov(vals))
samples <- extract_metrics(mraster, srs_wo, data.frame = TRUE)
samples
samples[,3:ncol(samples)]
load_all()
k <- analyze_COOBS(mraster = mraster, existing = existing, cores = 8)
k <- analyze_COOBS(mraster = mraster, existing = srs_wo, cores = 8)
i=1
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals <- vals %>%
dplyr::filter(complete.cases(.))
covMat<- as.matrix(cov(vals))
samples <- extract_metrics(mraster, srs_wo, data.frame = TRUE)
cell <- vals[i,]
pixDist <- stats::mahalanobis(x = as.matrix(vals), center = as.matrix(cell), cov = covMat)
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
sampDist<- stats::mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
covMat
covMat<- as.matrix(cov(vals[,3:ncol(vals)]))
covMat
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals <- vals %>%
dplyr::filter(complete.cases(.))
covMat<- as.matrix(cov(vals[,3:ncol(vals)]))
samples <- extract_metrics(mraster, srs_wo, data.frame = TRUE)
cell <- vals[i,]
pixDist <- stats::mahalanobis(x = as.matrix(vals), center = as.matrix(cell), cov = covMat)
pixMin <- min(pixDist)
vals
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
as.matrix(vals[,3:ncol(vals)])
as.matrix(cell)
cell <- vals[i,3:ncol(vals)]
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
pixDist
as.matrix(samples[,3:ncol(samples)])
as.matrix(cell)
covMat
load_all()
k <- analyze_COOBS(mraster = mraster, existing = srs_wo, cores = 8)
oper1 <- foreach::foreach(i=1, .combine = "c") %dopar% {
cell <- vals[i,3:ncol(vals)]
#--- Determine distance for each pixel in raster ---#
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
#--- Determine min and max distance values for each ---#
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
#--- Determine distance for each sample location ---#
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
#--- Normalize distance between data and samples)
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
#--- If sampDist > 1 sampDist > maxDist ---#
sampNDist[sampNDist > 1] <- 1
#--- larger values equate to more similarity ---#
sampNDist <- 1 - sampNDist
}
oper1 <- foreach::foreach(i=1, .combine = "c") %dopar% {
cell <- vals[i,3:ncol(vals)]
#--- Determine distance for each pixel in raster ---#
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
#--- Determine min and max distance values for each ---#
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
#--- Determine distance for each sample location ---#
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
#--- Normalize distance between data and samples)
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
#--- If sampDist > 1 sampDist > maxDist ---#
sampNDist[sampNDist > 1] <- 1
#--- larger values equate to more similarity ---#
sampNDist <- 1 - sampNDist
}
cl <- snow::makeCluster(spec = 1)
doParallel::registerDoParallel(cl)
oper1 <- foreach::foreach(i=1, .combine = "c") %dopar% {
cell <- vals[i,3:ncol(vals)]
#--- Determine distance for each pixel in raster ---#
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
#--- Determine min and max distance values for each ---#
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
#--- Determine distance for each sample location ---#
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
#--- Normalize distance between data and samples)
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
#--- If sampDist > 1 sampDist > maxDist ---#
sampNDist[sampNDist > 1] <- 1
#--- larger values equate to more similarity ---#
sampNDist <- 1 - sampNDist
}
threshold = 0.95
oper1 <- foreach::foreach(i=1, .combine = "c") %dopar% {
cell <- vals[i,3:ncol(vals)]
#--- Determine distance for each pixel in raster ---#
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
#--- Determine min and max distance values for each ---#
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
#--- Determine distance for each sample location ---#
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
#--- Normalize distance between data and samples)
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
#--- If sampDist > 1 sampDist > maxDist ---#
sampNDist[sampNDist > 1] <- 1
#--- larger values equate to more similarity ---#
sampNDist <- 1 - sampNDist
}
oper1
sampNDist
cell <- vals[i,3:ncol(vals)]
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
sampNDist[sampNDist > 1] <- 1
sampNDist <- 1 - sampNDist
sampNDist
i
cell
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
pixDist
pixMin <- min(pixDist)
pixMin
pixMax <- quantile(pixDist, probs = threshold)
pixMax
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
sampDist
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
sampNDist
sampNDist[sampNDist > 1] <- 1
sampNDist
sampNDist <- 1 - sampNDist
sampNDist
#--- End parallel ---#
snow::stopCluster(cl)
cl <- snow::makeCluster(spec = 1)
doParallel::registerDoParallel(cl)
oper1 <- foreach::foreach(i=1, .combine = "c") %dopar% {
cell <- vals[i,3:ncol(vals)]
#--- Determine distance for each pixel in raster ---#
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
#--- Determine min and max distance values for each ---#
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
#--- Determine distance for each sample location ---#
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
#--- Normalize distance between data and samples)
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
#--- If sampDist > 1 sampDist > maxDist ---#
sampNDist[sampNDist > 1] <- 1
#--- larger values equate to more similarity ---#
sampNDist <- 1 - sampNDist
#--- establish count above threshold ---#
sum(datNdist >= threshold)}
oper1 <- foreach::foreach(i=1, .combine = "c") %dopar% {
cell <- vals[i,3:ncol(vals)]
#--- Determine distance for each pixel in raster ---#
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
#--- Determine min and max distance values for each ---#
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
#--- Determine distance for each sample location ---#
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
#--- Normalize distance between data and samples)
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
#--- If sampDist > 1 sampDist > maxDist ---#
sampNDist[sampNDist > 1] <- 1
#--- larger values equate to more similarity ---#
sampNDist <- 1 - sampNDist
#--- establish count above threshold ---#
sum(sampNDist >= threshold)}
oper1
#--- End parallel ---#
snow::stopCluster(cl)
#--- End parallel ---#
snow::stopCluster(cl)
load_all()
load_all()
k <- analyze_COOBS(mraster = mraster, existing = srs_wo, cores = 8)
k
load_all()
k <- analyze_COOBS(mraster = mraster, existing = srs_wo, cores = 8)
k
plot(k)
mraster <- wall_poly[[1:8]]
k <- analyze_COOBS(mraster = mraster, existing = srs_wo, cores = 8)
plot(k)
cell <- vals[i,3:ncol(vals)]
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
pixDist
k <- analyze_COOBS(mraster = mraster, existing = srs_wo, cores = 8, threshold = 0.99)
plot(k)
k <- analyze_COOBS(mraster = mraster, existing = srs_wo, cores = 8, threshold = 0.975)
plot(k)
cell <- vals[i,3:ncol(vals)]
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
sampNDist[sampNDist > 1] <- 1
sampNDist <- 1 - sampNDist
#--- establish count above threshold ---#
sum(sampNDist >= threshold)
sampNDist
#--- define desired stratification raster ---#
sraster <- kmeans
#--- SRS **without** access defined---#
#--- 'mindist' between samples defaults to 100 ---#
srs_wo <- sample_srs(sraster = sraster,
n = 50,
plot = TRUE)
load_all()
k <- analyze_COOBS(mraster = mraster, existing = srs_wo, cores = 8)
plot(k)
plot(mraster)
plot(mraster[[1]])
plot(srs_wo,add=TRUE)
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals <- vals %>%
dplyr::filter(complete.cases(.))
covMat <- as.matrix(cov(vals[,3:ncol(vals)]))
samples <- extract_metrics(mraster, srs_wo, data.frame = TRUE)
samples
load_all()
k <- analyze_COOBS(mraster = mraster, existing = srs_wo, cores = 8)
plot(k)
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals <- vals %>%
dplyr::filter(complete.cases(.))
covMat <- as.matrix(cov(vals[,3:ncol(vals)]))
existing <- srs_wo
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals <- vals %>%
dplyr::filter(complete.cases(.))
covMat <- as.matrix(cov(vals[,3:ncol(vals)]))
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
samples
vals
vals[is.infinite(vals)]
vals[is.na(vals)]
vals <- terra::as.data.frame(mraster, xy = TRUE, row.names = FALSE)
vals <- vals %>%
dplyr::filter(complete.cases(.))
covMat <- as.matrix(cov(vals[,3:ncol(vals)]))
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
covMat
samples <- extract_metrics(mraster, existing, data.frame = TRUE)
i=200
i=10
cell <- vals[i,3:ncol(vals)]
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
sampNDist[sampNDist > 1] <- 1
sampNDist <- 1- sampNDist
#--- establish count above threshold ---#
sum(sampNDist >= threshold)
i=7
cell <- vals[i,3:ncol(vals)]
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
sampNDist[sampNDist > 1] <- 1
sampNDist <- 1- sampNDist
#--- establish count above threshold ---#
sum(sampNDist >= threshold)
loop <- foreach::foreach(i=1:nrow(vals), .combine = "c") %dopar% {
cell <- vals[i,3:ncol(vals)]
#--- Determine distance for each pixel in raster ---#
pixDist <- stats::mahalanobis(x = as.matrix(vals[,3:ncol(vals)]), center = as.matrix(cell), cov = covMat)
#--- Determine min and max distance values for each ---#
pixMin <- min(pixDist)
pixMax <- quantile(pixDist, probs = threshold)
#--- Determine distance for each sample location ---#
sampDist<- mahalanobis(x = as.matrix(samples[,3:ncol(samples)]), center = as.matrix(cell), cov = covMat) #calculate distance of observations to all other pixels
#--- Normalize distance between data and samples)
sampNDist <- (sampDist - pixMin) / (pixMax - pixMin)
#--- If sampDist > 1 sampDist > maxDist ---#
sampNDist[sampNDist > 1] <- 1
#--- larger values equate to more similarity ---#
sampNDist <- 1- sampNDist
#--- establish count above threshold ---#
sum(sampNDist >= threshold)
}
load_all()
k <- analyze_COOBS(mraster = mraster, existing = srs_wo, cores = 8)
library(sgsR)
library(terra)
library(sf)
library(RColorBrewer)
library(dplyr)
library(tidyr)
library(ggplot2)
library(spatstat)
#--- import ALS metrics raster ---#
raster <- system.file("extdata","rmf_metrics.tif", package = "sgsR")
raster <- terra::rast(raster)
library(devtools)
load_all()
library(sgsR)
library(terra)
library(sf)
library(RColorBrewer)
library(dplyr)
library(tidyr)
library(ggplot2)
library(spatstat)
#--- import ALS metrics raster ---#
raster <- system.file("extdata","rmf_metrics.tif", package = "sgsR")
raster <- terra::rast(raster)
names(raster) <- c("zmax","zmean","zsd","pzabove2","zq20","zq50","zq70","zq90","zq95","l_1","l_2","t_3","t_4")
#--- import forest inventory polygon and mask unwanted areas ---#
poly <- system.file("extdata","inventory_polygons.shp", package = "sgsR")
poly <- sf::st_read(poly)
#--- import access layer to be used during sampling if desired ---#
roads <- system.file("extdata","roads.shp", package = "sgsR")
roads <- sf::st_read(roads)
#--- manipulate inventory polygon to mask out unwanted areas ---#
poly_subset <- poly[poly$POLYTYPE == "FOR" & poly$OWNER == 1, ]
poly_subset <- sf::st_union(poly_subset)
poly_subset <- terra::vect(poly_subset)
#--- mask input ALS raster using polygon layer ---#
wall_poly <- terra::mask(raster,
poly_subset)
terra::plot(wall_poly[[1:2]])
#--- perform stratification using k-means ---#
kmeans <- strat_kmeans(mraster = wall_poly[[1]], nstrata = 4)
plot(kmeans)
#--- set 'details' = TRUE to get algorithm details and outputs ---#
#--- define desired stratification raster ---#
sraster <- kmeans
#--- SRS **without** access defined---#
#--- 'mindist' between samples defaults to 100 ---#
srs_wo <- sample_srs(sraster = sraster,
n = 50,
plot = TRUE)
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo,cores = 8)
plot(k)
#--- define desired stratification raster ---#
sraster <- kmeans
#--- SRS **without** access defined---#
#--- 'mindist' between samples defaults to 100 ---#
srs_wo <- sample_srs(sraster = sraster,
n = 200,
plot = TRUE)
k <- analyze_COOBS(mraster = wall_poly[[1:3]],existing = srs_wo,cores = 8)
plot(k)
