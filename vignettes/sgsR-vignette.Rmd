---
title: "sgsR-vignette"
author: "Tristan Goodbody"
output:
  html_document:
    df_print: paged
vignette: >
  %\VignetteIndexEntry{sgsR-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE, eval = FALSE}
knitr::opts_chunk$set(error = TRUE)
```

### sgsR vignette

```{r message=FALSE, warning=FALSE}
library(sgsR)
library(terra)
library(sf)
library(RColorBrewer)
library(dplyr)
library(tidyr)
library(ggplot2)
library(spatstat)

```

```{r}
#--- import ALS metrics raster ---#

raster <- system.file("extdata","wall_metrics.tif", package = "sgsR")

mraster <- terra::rast(raster)

names(mraster) <- c("zmax","zmean","zsd","pzabove2","zq20","zq50","zq70","zq90","zq95")

#--- import forest inventory polygon and mask unwanted areas ---#
poly <- system.file("extdata","inventory_polygons.shp", package = "sgsR")

poly <- sf::st_read(poly)

#--- import access layer to be used during sampling if desired ---#

roads <- system.file("extdata","roads.shp", package = "sgsR")

roads <- sf::st_read(roads)

```

```{r}
#--- manipulate inventory polygon to mask out unwanted areas ---#

poly_subset <- poly[poly$POLYTYPE == "FOR" & poly$OWNER == 1, ]
poly_subset <- sf::st_union(poly_subset)

poly_subset <- terra::vect(poly_subset)

#--- mask input ALS raster using polygon layer ---#

wall_poly <- terra::mask(mraster,
                         poly_subset)

terra::plot(wall_poly[[1:2]])

```

## Stratification Methods

### k-means stratification
```{r}
#--- perform stratification using k-means ---#
kmeans <- strat_kmeans(mraster = wall_poly[[1:6]], nStrata = 10)

plot(kmeans)


#--- set 'details' = TRUE to get algorithm details and outputs ---#

```

### Optimum sample breaks

```{r,eval=FALSE}
#--- perform stratification using OSB ---#
#--- note that this one can take a while ---#

osb <- strat_osb(mraster = wall_poly$pzabove2,
                 nStrata = 2,
                 nSamp = 10,
                 details = TRUE,
                 plot = TRUE)

osb$details

```

### User-defined breaks
## Single metric stratification
```{r}
#--- perform stratification using user-defined breaks ---#

#--- define breaks for metric ---#
breaks <- c(seq(0,100,20))

breaks

#--- stratify on 1 metric only ---#

bk1 <- strat_breaks(mraster = wall_poly$zmean,
                 breaks = breaks,
                 details = TRUE,
                 plot = TRUE)

```

```{r}
#--- perform stratification using user-defined breaks ---#

values <- terra::values(wall_poly$zmean)

#--- define breaks for metric ---#
breaks <- quantile(values, na.rm=TRUE)

breaks

#--- stratify on 1 metric only ---#

bk1 <- strat_breaks(mraster = wall_poly$zmean,
                 breaks = breaks,
                 details = TRUE,
                 plot = TRUE)

```

## Dual metric stratification
```{r}
#--- stratify on 2 metrics ---#

breaks2 <- c(seq(3,30,10))

breaks2

bk2 <- strat_breaks(mraster = wall_poly$zmean,
                    mraster2 = wall_poly$zq95,
                    breaks = breaks,
                    breaks2 = breaks2,
                    details = TRUE,
                    plot = TRUE)

```

### Principal components analysis
```{r}

#--- perform stratification using principal components on P1 only ---#
pcomp1 <- strat_pcomp(mraster = wall_poly,
                      nStrata = 4,
                      plot = TRUE,
                      details = TRUE)

pcomp1 <- strat_pcomp(mraster = wall_poly,
                      nStrata = 4,
                      nStrata2 = 6,
                      plot = TRUE,
                      details = TRUE)

```

```{r}

#--- perform stratification using principal components on P1 and P2 ---#
pcomp2 <- strat_pcomp(mraster = wall_poly,
                      nStrata = 10, 
                      nStrata2 = 10)

#--- number of output strata will always be equal to ---#
#--- 'nstrata' * 'nstrata2' (if 'nstrata2' is provided) ---#

plot(pcomp2)

#--- set 'details' = TRUE to get algorithm details and outputs ---#

```

## Sampling
### Simple random sampling (SRS)
```{r}

#--- define desired stratification raster ---#
raster <- kmeans

#--- SRS **without** access defined---#

existing <- sample_srs(raster = raster,
                  n = 250,
                  plot = TRUE)

```

```{r}

#--- increase desired samples and mindist parameter ---#
srs_md <- sample_srs(raster = raster,
                     nSamp = 300, 
                     mindist = 300,
                     plot = TRUE)

```

### SRS with access defined
```{r}

#--- sampling **with** access defined---#

#--- we want 200 samples with 200m min distance between each ---#
#--- we also provide an `access` polygon, which is linear road features ---#
#--- we specify we want an internal buffer ('buff_inner') of 50 ---#
#--- we also speficy we want an external buffer ('buff_outer') of 200 ---#

srs_w <- sample_srs(raster = raster,
                  n = 200,
                  mindist = 200,
                  access = roads,
                  buff_inner = 50,
                  buff_outer = 200,
                  plot = TRUE)


```

### Stratified sampling
```{r}

#--- stratified sampling **without** access defined---#

#--- 'mindist' between samples defaults to 0 ---#
strat_wo <- sample_strat(sraster = kmeans, 
                         nSamp = 200,
                         plot = TRUE)

```

```{r}
#--- change mindist parameter ---#
strat_md <- sample_strat(sraster = kmeans,
                      nSamp = 362, 
                      mindist = 200,
                      plot = TRUE)

```

```{r}

#--- stratified sampling with access and buffers provided ---#
strat_w_a <- sample_strat(sraster = kmeans,
                        nSamp = 200, 
                        mindist = 200,
                        access = roads,
                        buff_inner = 50,
                        buff_outer = 200,
                        plot = TRUE)

#--- optimal allocation ---#

sample_strat(sraster = kmeans,
             nSamp = 200, 
             mindist = 200,
             force = TRUE,
             allocation = "optim",
             mraster = mraster$zmean,
             access = roads,
             buff_inner = 170,
             buff_outer = 264,
             plot = TRUE)

```

## Balanced Sampling - uses metrics rasters
### `lpm2` method

```{r,eval=FALSE}

#--- stratified sampling with access and buffers provided ---#
bal_wo <- sample_balanced(mraster = wall_poly,
                        n = 200, 
                        algorithm = "lpm2",
                        plot = TRUE)
```

### `lpm2` with access provided

```{r,eval=FALSE}
#--- stratified sampling with access and buffers provided ---#
bal_w_a <- sample_balanced(mraster = wall_poly,
                        n = 200, 
                        algorithm = "lpm2",
                        access = roads,
                        buff_inner = 50,
                        buff_outer = 200,
                        plot = TRUE)
```

### `lcube` algorithm - Slower

```{r,eval=FALSE}

#--- stratified sampling with access and buffers provided ---#
bal_wo <- sample_balanced(mraster = wall_poly,
                        n = 200, 
                        algorithm = "lcube",
                        plot = TRUE)
```

### `lcube` with access provided - Slower

```{r,eval=FALSE}
#--- stratified sampling with access and buffers provided ---#
bal_w_a <- sample_balanced(mraster = wall_poly,
                        n = 200, 
                        algorithm = "lcube",
                        access = roads,
                        buff_inner = 50,
                        buff_outer = 200,
                        plot = TRUE)
```

### `lcubestratified` algorithm

```{r,eval=FALSE}
#--- need to add a variable named strata to enable stratified sampling ---#
mraster <- c(wall_poly,kmeans)

#--- stratified sampling with access and buffers provided ---#
bal_wo <- sample_balanced(mraster = mraster,
                        n = 200, 
                        algorithm = "lcubestratified",
                        plot = TRUE)
```

## `lcubestratified` - with access provided

```{r,eval=FALSE}
#--- stratified sampling with access and buffers provided ---#
bal_w_a <- sample_balanced(mraster = mraster,
                        n = 200, 
                        algorithm = "lcubestratified",
                        access = roads,
                        buff_inner = 50,
                        buff_outer = 200,
                        plot = TRUE)
```

## Incorporating existing sample networks

```{r}

#--- extract strata from raster for already existing sample network ---#
#--- we use random samples defined above ---#

existing <- extract_strata(sraster = kmeans,
                           existing = existing)

#--- if 'data.frame = TRUE -- output will be a dataframe instead of an sf object ---#

```

### Stratified sampling in presense of existing plot networks
```{r}
#--- sampling **with** access defined **and** existing samples defined ---#

#--- we want 200 samples with 200m min distance between each ---#
#--- we specify we have an existing plot network to include in our sampling ---#
#--- we also provide an `access` polygon, which is linear road features ---#
#--- we specify we want an internal buffer ('buff_inner') of 50 ---#
#--- we also specify we want an external buffer ('buff_outer') of 200 ---#


strat_w_e <- sample_strat(sraster = kmeans,
                        n = 200, 
                        mindist = 200,
                        existing = existing,
                        access = roads,
                        buff_inner = 50,
                        buff_outer = 200,
                        plot = TRUE)

#--- red plots are existing and black are new ---#

#--- how many samples did we get total? ---#
strat_w_e


#--- equal allocation ---#

o <- sample_strat(sraster = kmeans,
             nSamp = 20, 
             mindist = 400,
             existing = existing,
             include = FALSE,
             allocation = "equal",
             force = TRUE,
             plot = TRUE)

```

Notice that we specified that we wanted 200 samples but we get 250. That's because the existing samples were not included within the `n` parameter total. To include the existing samples within the context of their strata we can set `include = TRUE` and we will get the value of `n` we specify with all `existing` samples included.

```{r}

#--- sampling **with** access defined **and** existing samples defined ---#

#--- we want 200 samples with 200m min distance between each ---#
#--- we specify we have an existing plot network to include in our sampling ---#
#--- we also provide an `access` polygon, which is linear road features ---#
#--- we specify we want an internal buffer ('buff_inner') of 50 ---#
#--- we also specify we want an external buffer ('buff_outer') of 200 ---#


strat_w_e_i <- sample_strat(sraster = kmeans,
                        n = 200, 
                        mindist = 200,
                        existing = existing,
                        include = TRUE, #--- including our existing plots to reach 200 samples ---#
                        access = roads,
                        buff_inner = 50,
                        buff_outer = 200,
                        plot = TRUE)


#--- how many samples did we get total? ---#
strat_w_e_i

```

## Extract als metrics from samples for future modelling
```{r}
#--- extract metrics from multi-band ALS raster for potential modeling ---#

metrics <- extract_metrics(mraster = wall_poly,
                           existing = strat_w_e_i)

metrics

#--- if 'data.frame = TRUE -- output will be a dataframe instead of an sf object ---#

```

